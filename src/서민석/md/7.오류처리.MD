### 오류코드보단 예외를 사용하라
```java
public class DeviceController {
  ...
  public void sendShutDown() {
    DeviceHandle handle = getHandle(DEV1);
    // Check the state of the device
    if (handle != DeviceHandle.INVALID) {
      // Save the device status to the record field
      retrieveDeviceRecord(handle);
      // If not suspended, shut down
      if (record.getStatus() != DEVICE_SUSPENDED) {
        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
      } else {
        logger.log("Device suspended. Unable to shut down");
      }
    } else {
      logger.log("Invalid handle for: " + DEV1.toString());
    }
  }
  ...
}
```
예외처리 블록 없이 조건문으로 메서드를 호출 하는 방식의 문제점은 호출자의 코드가 복잡해진다.
호출자는 메서드를 호출하는 즉시 발생하는 오류에대해 확인해야 하기 때문이다.

```java
public class DeviceController {
  ...
  public void sendShutDown() {
    try {
      tryToShutDown();
    } catch (DeviceShutDownError e) {
      logger.log(e);
    }
  }
    
  private void tryToShutDown() throws DeviceShutDownError {
    DeviceHandle handle = getHandle(DEV1);
    DeviceRecord record = retrieveDeviceRecord(handle);
    pauseDevice(handle); 
    clearDeviceWorkQueue(handle); 
    closeDevice(handle);
  }
  
  private DeviceHandle getHandle(DeviceID id) {
    ...
    throw new DeviceShutDownError("Invalid handle for: " + id.toString());
    ...
  }
  ...
}


```
두 코드 예제에서 저자가 말하는 오류처리와 깨끗한 코드의 연관성을 볼 수있다.
첫번째 코드의 디바이스를 종료하는 부분과 오류처리 알고리즘부분을 나누어 
코드가 깔끔해 졌다.


예외처리를 하지않을 이유는 없다.
우리가 사용하는 프로그램이나 디바이스가 예측하지 못한 입력이
있을 수 있고, 어떤 이유로던 실패할 가능성이 있기 때문이다.




### Try,Catch,Finally
try문은 transaction처럼 동작하는 실행코드로, catch문은 try문에 관계없이 프로그램을 일관적인 상태로 유지하도록 한다.
이렇게 함으로써 코드의 "Scope 정의"가 가능해진다.
예시: 잘못된 input을 넣을 경우 StorageException을 제대로 던지는지 확인하는 테스트 코드를 작성해보자


### UncheckedException 을 사용하자

try문은 transaction처럼 동작하는 실행코드로, 
catch문은 try문에 관계없이 프로그램을 일관적인 상태로 유지하도록 한다.

이렇게 함으로써 코드의 "Scope 정의"가 가능해진다.
잘못된 input을 넣을 경우 StorageException을 제대로 던지는지 확인하는 테스트 코드를 작성해보자

```java
@Test(expected = StorageException.class)
  public void retrieveSectionShouldThrowOnInvalidFileName() {
    sectionStore.retrieveSection("invalid - file");
  }
  
  public List<RecordedGrip> retrieveSection(String sectionName) {
    // dummy return until we have a real implementation
    return new ArrayList<RecordedGrip>();
  }
```

```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    try {
      FileInputStream stream = new FileInputStream(sectionName)
    } catch (Exception e) {
      throw new StorageException("retrieval error", e);
    }
  return new ArrayList<RecordedGrip>();
}
```

```java
public List<RecordedGrip> retrieveSection(String sectionName) {
    try {
      FileInputStream stream = new FileInputStream(sectionName);
      stream.close();
    } catch (FileNotFoundException e) {
      throw new StorageException("retrieval error", e);
    }
    return new ArrayList<RecordedGrip>();
  }
```



### NULL 값은 반환하지말자
```java
public void registerItem(Item item) {
    if (item != null) {
      ItemRegistry registry = peristentStore.getItemRegistry();
      if (registry != null) {
        Item existing = registry.getItem(item.getID());
        if (existing.getBillingPeriod().hasRetailOwner()) {
          existing.register(item);
        }
      }
    }
  }
```

```java
  List<Employee> employees = getEmployees();
  if (employees != null) {
    for(Employee e : employees) {
      totalPay += e.getPay();
    }
  }
```

```java
 List<Employee> employees = getEmployees();
  for(Employee e : employees) {
    totalPay += e.getPay();
  }
  
  public List<Employee> getEmployees() {
    if( .. there are no employees .. )
      return Collections.emptyList();
    }
}
```

null 을 리턴하는 것도 나쁘지만 메서드로 넘기는 것은 더 나쁘다.
null 을 메서드의 파라미터로 넣어야 하는 API 를 사용하는 경우가 아니면 메서드로 넘기지 마라.

일반적으로 대다수의 프로그래밍 언어들은 파라미터로 들어온 null 에 대해 적절한 방법을 제공하지 않는다.
가장 이상적인 방법은 null 을 파라미터로 받지 못하게 하는 것이다.
