## 1. 깨끗한 코드

저자는 이 책에 들어가기 앞서

"코드는 더 이상 문제가 아니다", "모델이나 요구사항에 집중해야 한다" 등등
코드의 종말이 코앞에 닥쳤다고 주장하는 사람이 없지 않다고 말한다.
**코드를 자동으로 생성하는 시대가 다가온다는 말**이다. 하지만 저자는
코드, 즉 프로그래머가 사라질 가망은 전혀 없다고 말한다. 왜냐하면 코드는
**요구사항을 상세히 표현하는 언어**이니까.
기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업이 컴퓨터 프로그래밍이다.

보통 대부분의 프로그래머라면 프로젝트를 진행해 보았을 것이다.
프로젝트 초반에는 일이 참 잘 진행된다. 코드도 막힘없이, 생각을 덜 하면서
쭉쭉 짜서 구현한다. 하지만 프로젝트 중반부부터 코드를 고칠 때마다 엉뚱한 곳에서
문제가 생긴다. **그 문제를 해결하기 위해** 얽히고 설킨 코드를 해독해서
또 다시 얽히고 설킨 코드를 더해 문제를 해결한다.

시간이 지나면서 쓰레기 더미는 점점 높아지고 깊어지고 커져버린다. 이제 어디부터
손대야할지 감조차 잡히지 않는다.
**나쁜 코드가 쌓일수록 팀 생산성은 떨어진다.**

대부분의 프로그래머가 기한을 맞추려면 나쁜 코드를 양산할 수 밖에 없다고 느낀다.
그러나 **기한을 맞추는 유일한 방법**은, 즉 빨리 목표를 달성할 수 있는 유일한 방법은
언제나 **코드를 깨끗히 유지하는 습관**이다.

###  어떻게 깨끗한 코드를 작성할까?
저자는 깨끗한 코드를 구현하는 행위를 그림을 그리는 행위에 **비유**한다.
그림을 보면 대부분의 사람들은 잘 그려졌는지 엉망으로 그려졌는지 알지만, 잘 그린 그림을 구분하는 능력이
그림을 잘 그리는 능력은 아니다. 이처럼 코드도 똑같은 것이다.

저자는 핵심이 `코드 감각`이라고 이야기 한다.

저자는 `깨진 유리창 이론`을 예시로 들면서 **나쁜 코드는 나쁜 코드를 유혹한다**를 설명한다.
그리고 대부분의 프로그래머들이 **대충 넘어가는 부분**들을 말한다.

**대충 넘어가는 부분들**
- 1. 오류 처리
- 2. 메모리 누수
- 3. 경쟁 상태(프로그램이나 시스템 등의 실행/출력 결과가 일정하지 않고, 실행되는 순서나 시간 등에 영향을 받게 되는 상태)
- 4. 일관성 없는 명명법

내용을 정리하면 `깨끗한 코드`는 **한 가지를 잘하고**, **잘 읽히고**,
**다른 사람이 고치기 쉽다**.

## 느낀 점
이 챕터를 읽으면서 결국 저자가 하고 싶은 말은 `깨끗한 코드`를 만들 때,
내가 느낀 바로는 **추상화**를 중요시해라, **중복을 피해라**, **한 기능만 수행해라**
를 말하고 싶었던 것 같다. 그리고 대충 넘어가는 부분들을 나열할 때 많이
와닿았다. 그 부분에서 1번(오류 처리), 2번이(메모리 누수).
내가 지금까지 코드를 짜면서(아직 경험이 부족해서 그런건지는 몰라도) 1번과 2번은
잘 생각하지 않으면서 코드를 짜왔기 때문이다. 이 책을 읽으면서 이러한 점을
개선할 수 있게 되면 더 발전할 수 있을 것 같다.








